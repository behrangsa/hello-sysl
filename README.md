# Hello Sysl

Sysl is an open source tool that is developed by Australia's ANZ bank and is used internally by various
engineering teams.

Here we use Sysl to build an API that can respond to `GET /hello` messages.

First create a minimal sysl specification:

```bash
$ cd ~/Projects
$ mkdir hello-sysl
$ cd hello-sysl
$ mkdir specs
$ cd specs
$ touch hello.sysl
```

Add this content to `hi.sysl`:

```
Hello:
    @package="Hello"
    /hello:
        GET:
            return ok <: Message

    !type Message:
        body <: string
```

Here we define an API that:

* When we generate code for, it should belong to the `Hello` package.
* Has one REST endpoint at the `/hello` path.
** The endpoint only responds to `GET` requests.
** For the `200 OK` response, it will return a response of type `Message` (`return ok <: Message`)
** `Message` is an "object" that has a string field named `body`

Let's validate our specification:

```bash
$ sysl validate specs/hello.sysl 
```

An empty output means that our specification is valid (is parsed successfully).

Now let's parse the spec and generate a Golang project:

```bash
$ docker run -it --rm -v `pwd`:/work anzbank/sysl-go:latest
  ? Sysl model path (default: "./specs/hello.sysl"): 
  ? Go module name (default: "hello"): 
  ? App to codegen (default: "Hello"): 
  ? Package name for "Hello" (default: "hello"): 
  ? Add another app (y/N)? n
go: creating new go.mod: module hello
Codegen ready! To generate code, run make.

$ $ make
# note: if we use > model.json here then if we are running inside a
# terminal, then sysl pb detects that and logs warnings
# to stdout which pollute our JSON output. So use --output model.json.
docker run --rm -t -v $(pwd):/work -w /work --entrypoint sysl anzbank/sysl-go:v0.159.0 pb --mode json --root . specs/hello.sysl --output model.json || (rm model.json && false)
docker run --rm -t -v $(pwd):/work -w /work --entrypoint arrai anzbank/sysl-go:v0.159.0 --out=dir:. /sysl-go/codegen/arrai/auto/auto.arrai hello hello internal/gen/pkg/servers/hello model.json Hello =
find internal/gen/pkg/servers/hello -type d | xargs docker run --rm -t -v $(pwd):/work -w /work --entrypoint goimports anzbank/sysl-go:v0.159.0 -w
touch internal/gen/pkg/servers/hello
touch: setting times of 'internal/gen/pkg/servers/hello': Permission denied
make: *** [codegen.mk:99: internal/gen/pkg/servers/hello] Error 1
rm model.json
```

Due to a bug some of the generated files and directories that are generated by make belong to `root:root`:

```
drwxrwxr-x 6 behi 		behi 4.0K Dec 16 05:44 .
drwxrwxr-x 7 behi 		behi 4.0K Dec 16 05:27 ..
drwxr-xr-x 3 root       root      4.0K Dec 16 05:44 cmd
-rw-r--r-- 1 root       root      3.3K Dec 16 05:43 codegen.mk
-rw-r--r-- 1 root       root       235 Dec 16 05:44 Dockerfile
-rw-r--r-- 1 root       root       109 Dec 16 05:44 .gitattributes
drwxr-xr-x 3 root       root      4.0K Dec 16 05:44 .github
-rw-r--r-- 1 root       root        21 Dec 16 05:44 .gitignore
-rw-r--r-- 1 root       root        22 Dec 16 05:43 go.mod
drwxr-xr-x 3 root       root      4.0K Dec 16 05:44 internal
-rw-r--r-- 1 root       root       116 Dec 16 05:43 Makefile
-rw-r--r-- 1 root       root       821 Dec 16 05:44 README.md
drwxrwxr-x 2 behi       behi      4.0K Dec 16 05:28 specs
```

To fix this, let's fix the ownership of the files and rerun make:

```bash
$ sudo chown -R behi:behi .
behi@Chopin:~/Projects/hello-sysl$ ls -alh
total 52K
drwxrwxr-x 6 behi behi 4.0K Dec 16 05:44 .
drwxrwxr-x 7 behi behi 4.0K Dec 16 05:27 ..
drwxr-xr-x 3 behi behi 4.0K Dec 16 05:44 cmd
-rw-r--r-- 1 behi behi 3.3K Dec 16 05:43 codegen.mk
-rw-r--r-- 1 behi behi  235 Dec 16 05:44 Dockerfile
-rw-r--r-- 1 behi behi  109 Dec 16 05:44 .gitattributes
drwxr-xr-x 3 behi behi 4.0K Dec 16 05:44 .github
-rw-r--r-- 1 behi behi   21 Dec 16 05:44 .gitignore
-rw-r--r-- 1 behi behi   22 Dec 16 05:43 go.mod
drwxr-xr-x 3 behi behi 4.0K Dec 16 05:44 internal
-rw-r--r-- 1 behi behi  116 Dec 16 05:43 Makefile
-rw-r--r-- 1 behi behi  821 Dec 16 05:44 README.md
drwxrwxr-x 2 behi behi 4.0K Dec 16 05:28 specs

$ make
make: Nothing to be done for 'gen-all-servers'.
```

Run go mod tidy to generate the `go.sum` file:

```bash
$ go mod tidy
```

Now we are ready to write the handler code for the `GET /hello` endpoint that we defined in our spec:

```bash
$ mkdir internal/handlers
$ touch internal/handlers/hello.go
```

Our handler code looks like this:

```go
package handlers

import (
	"context"
	"hello/internal/gen/pkg/servers/hello"

	"github.com/anz-bank/sysl-go/common"
)

// GetHelloListRequest returns a hello message
func GetHelloListRequest(ctx context.Context, getHelloListRequest *hello.GetHelloListRequest) (*hello.Message, error) {

	// Set response content type to JSON
	headers := common.RequestHeaderFromContext(ctx)
	headers["Content-Type"] = []string{"application/json; charset=utf-8"}

	// return the result
	return &hello.Message{
		Body: "Hello, World!",
	}, nil
}

```

It sets the content type to JSON and responds with `{"body" : "Hello, World!"}`.

Finally, we have to configure our application to route `GET` requests to `/hello` to our handler.
To do that, we need to modify the `cmd/hello/main.go` file that `sysl-go` generated for us:

```
func main() {
	hello.Serve(context.Background(),
		func(ctx context.Context, config AppConfig) (*hello.ServiceInterface, *core.Hooks, error) {
			// Perform one-time setup based on config here.
			return &hello.ServiceInterface{
				GetHelloList: handlers.GetHelloListRequest,
			}, nil, nil
		},
	)
}

```

Let's see if we can run our app:

```
$ go run cmd/hello/main.go
2020/12/16 06:08:36 Wrong number of arguments (usage: /tmp/go-build568084044/b001/exe/main (config | -h | --help))
exit status 1
```

The generated app, expcts a configuration file otherwise it won't run. Let's generate a basic configuration:


```bash
$ mkdir config
$ touch config/config.yaml
```

With the content:

```yaml
library:
  log:
    format: text
    level: info
    caller: false

genCode:
  upstream:
    contextTimeout: 120s
    http:
      basePath: /
      readTimeout: 120s
      writeTimeout: 120s
      common:
        hostName: ""
        port: 6060
  downstream:
    contextTimeout: 120s
```

Let's rerun our app using our basic configuration:

```bash
$ go run cmd/hello/main.go config/config.yaml 
2020-12-16T06:11:23.241306943+11:00 INFO no AdminServerConfig for REST was found 
2020-12-16T06:11:23.241338022+11:00 INFO found PublicServerConfig for REST 
2020-12-16T06:11:23.24139229+11:00 INFO configured listener for address: :6060/ 
2020-12-16T06:11:23.24140251+11:00 INFO no GrpcPublicServerConfig for gRPC was found 
2020-12-16T06:11:23.241446148+11:00 INFO starting sub-server 0 of 1 
2020-12-16T06:11:23.241455328+11:00 INFO no TLS configuration present. Preparing to serve HTTP for address: :6060/ 
```

We have succeeded! Let's send a request to our API and verify it indeed is working:

```bash
curl -iv localhost:6060/hello
*   Trying 127.0.0.1:6060...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 6060 (#0)
> GET /hello HTTP/1.1
> Host: localhost:6060
> User-Agent: curl/7.68.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
HTTP/1.1 200 OK
< Content-Type: application/json
Content-Type: application/json
< Date: Tue, 15 Dec 2020 19:13:57 GMT
Date: Tue, 15 Dec 2020 19:13:57 GMT
< Content-Length: 25
Content-Length: 25

< 
{"body":"Hello, World!"}
* Connection #0 to host localhost left intact
```

Success!

I had to modify the generate codegen.mk file a bit, but then I could run the containerized version of the API:

```bash
make docker.hello 
go mod tidy
docker build -t hello .
Sending build context to Docker daemon  23.95MB
Step 1/9 : ARG REGISTRY
Step 2/9 : FROM ${REGISTRY}${REGISTRY:+/}golang:alpine AS builder
 ---> fa4324ee842a
Step 3/9 : WORKDIR /app
 ---> Using cache
 ---> 85b91b30cbad
Step 4/9 : COPY . .
 ---> 2f4cb544ea98
Step 5/9 : RUN go build -mod=vendor -o hello ./cmd/hello
 ---> Running in 6fc26615254e
Removing intermediate container 6fc26615254e
 ---> 4c662cfc9563
Step 6/9 : FROM ${REGISTRY}${REGISTRY:+/}alpine
 ---> b14afc6dfb98
Step 7/9 : WORKDIR /app
 ---> Using cache
 ---> 5e6eaa7f7c29
Step 8/9 : COPY --from=builder /app/hello /bin/
 ---> Using cache
 ---> ae58c523f799
Step 9/9 : CMD hello
 ---> Using cache
 ---> bf38f1a06114
Successfully built bf38f1a06114
Successfully tagged hello:latest
docker run -p 6060:6060 -v $(pwd)/:/work hello hello /work/config/config.yaml
2020-12-15T20:02:29.973295833Z INFO no AdminServerConfig for REST was found 
2020-12-15T20:02:29.973313172Z INFO found PublicServerConfig for REST 
2020-12-15T20:02:29.973346542Z INFO configured listener for address: :6060/ 
2020-12-15T20:02:29.973351502Z INFO no GrpcPublicServerConfig for gRPC was found 
2020-12-15T20:02:29.973379481Z INFO starting sub-server 0 of 1 
2020-12-15T20:02:29.973385461Z INFO no TLS configuration present. Preparing to serve HTTP for address: :6060/ 


$ curl -iv localhost:6060/hello
*   Trying 127.0.0.1:6060...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 6060 (#0)
> GET /hello HTTP/1.1
> Host: localhost:6060
> User-Agent: curl/7.68.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
HTTP/1.1 200 OK
< Content-Type: application/json
Content-Type: application/json
< Date: Tue, 15 Dec 2020 20:03:51 GMT
Date: Tue, 15 Dec 2020 20:03:51 GMT
< Content-Length: 25
Content-Length: 25

< 
{"body":"Hello, World!"}
* Connection #0 to host localhost left intact
```

# Hello

## Prerequisites

- [Sysl v0.11.0 or later ](https://sysl.io/docs/install/)
- Go 1.13

## Building application Docker container image

To build a docker container image for the application using the template
Dockerfile, you first need to vendor all the dependencies. You can do so
with the command
```sh
go mod vendor
```

Then run:

```sh
docker build -t docker_hello -f Dockerfile .
```

## Running the application in a Docker container

o run the application inside the container, you need to prepare an
application config file. Assuming you have an application config file
present as `config.yml`, the containerised application can be run as:

```sh
docker run --rm -t -p 8080:8080 --mount type=bind,source="$PWD"/config.yml,target=/app/config.yml,readonly docker_hello:latest /bin/hello /app/config.yml
```
